# Глубина применения
При изучении внутренних механизмов работы CSS мы узнаём, что у нас есть селекторы. Селекторы используются для выборки со страницы определённых HTML-элементов, которые мы хотим стилизовать. За прошедшие годы CSS динамично развивался и рос, предоставляя нам всё большее число селекторов и большее число возможностей для использования этих селекторов. Однако каждый блок правил, который мы добавляем в таблицу стилей, создаёт всё большую связь между CSS и HTML.

Давайте рассмотрим типичный блок CSS-кода, который вы можете найти на каком-либо сайте.

```css
/* Как мы плотно связываем наш CSS с разметкой */
#sidebar div {
  border: 1px solid #333;
}

#sidebar div h3 { 
  margin-top: 5px;
}

#sidebar div ul {
  margin-bottom: 5px; 
}
```

Взглянув на этот код вы можете примерно оценить то, как будет выглядеть разметка. Скорее всего, в сайдбаре есть несколько секций, имеющих заголовок и следующий за ним маркированный список. Если сайт меняется и обновляется нечасто, то этот код будет работать неплохо. Я не менял дизайн своего блога два года. Поэтому у меня не было нужды в масштабировании CSS. Однако у меня бы возникли проблемы, если бы я попробовал применить такой подход на крупном проекте, который меняется чаще и имеет больше требований к коду. Мне пришлось бы добавить больше правил с более сложными селекторами. Поддержка этого кода стала бы для меня кошмаром.

Что же я сделал не так? В этом примере кода есть две конкретные проблемы:

1. Я слишком сильно привязываюсь к структуре разметки.
2. Вложенность селекторов слишком большая.

## Минимизация вложенности
HTML похож на древовидную структуру из родительских и дочерних элементов. Глубина применения — это количество поколений элементов, на которые влияет определённое правило. Например, `body.article > #main > #content > #intro > p > b` имеет глубину применения в 6 поколений. Если бы селектор был записан как `.article #intro b`, то глубина применения всё равно была бы в 6 поколений.

Проблема с глубиной заключается в том, что она обеспечивает гораздо большую зависимость от конкретной части разметки. Компоненты страницы нельзя будет легко переместить куда-либо. Давайте вспомним пример с сайдбаром. Как бы мы использовали этот модуль в другой части страницы, например в подвале? Нам пришлось бы дублировать правила.

```css
/* Дублирование правил */
#sidebar div, #footer div {
  border: 1px solid #333;
}

#sidebar div h3, #footer div h3 { 
  margin-top: 5px;
}

#sidebar div ul, #footer div ul {
  margin-bottom: 5px; 
} 
```

Корневой элемент модуля — `div`, и мы должны начинать стилизацию с него.

```css
/* Упрощение правил */
.pod {
  border: 1px solid #333;
}

.pod > h3 { 
  margin-top: 5px;
}

.pod > ul {
  margin-bottom: 5px; 
} 
```

Теперь `pod` — это контейнер, который всё ещё зависит от определённой структуры разметки, но зато мы добились гораздо меньшей вложенности, чем была изначально. Компромисс заключается в том, что нам придётся несколько раз повторять класс `.pod` в нашей разметке.