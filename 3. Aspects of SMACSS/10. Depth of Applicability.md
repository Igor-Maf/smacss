# Глубина применения
При изучении внутренних механизмов работы CSS мы узнаём, что у нас есть селекторы. Селекторы используются для выборки со страницы определённых HTML-элементов, которые мы хотим стилизовать. За прошедшие годы CSS динамично развивался и рос, предоставляя нам всё большее число селекторов и большее число возможностей для использования этих селекторов. Однако каждый блок правил, который мы добавляем в таблицу стилей, создаёт всё большую связь между CSS и HTML.

Давайте рассмотрим типичный блок CSS-кода, который вы можете найти на каком-либо сайте.

```css
/* Как мы плотно связываем наш CSS с разметкой */
#sidebar div {
  border: 1px solid #333;
}

#sidebar div h3 { 
  margin-top: 5px;
}

#sidebar div ul {
  margin-bottom: 5px; 
}
```

Взглянув на этот код вы можете примерно оценить то, как будет выглядеть разметка. Скорее всего, в сайдбаре есть несколько секций, имеющих заголовок и следующий за ним маркированный список. Если сайт меняется и обновляется нечасто, то этот код будет работать неплохо. Я не менял дизайн своего блога два года. Поэтому у меня не было нужды в масштабировании CSS. Однако у меня бы возникли проблемы, если бы я попробовал применить такой подход на крупном проекте, который меняется чаще и имеет больше требований к коду. Мне пришлось бы добавить больше правил с более сложными селекторами. Поддержка этого кода стала бы для меня кошмаром.

Что же я сделал не так? В этом примере кода есть две конкретные проблемы:

1. Я слишком сильно привязываюсь к структуре разметки.
2. Вложенность селекторов слишком большая.

## Минимизация вложенности
HTML похож на древовидную структуру из родительских и дочерних элементов. Глубина применения — это количество поколений элементов, на которые влияет определённое правило. Например, `body.article > #main > #content > #intro > p > b` имеет глубину применения в 6 поколений. Если бы селектор был записан как `.article #intro b`, то глубина применения всё равно была бы в 6 поколений.

Проблема с глубиной заключается в том, что она обеспечивает гораздо большую зависимость от конкретной части разметки. Компоненты страницы нельзя будет легко переместить куда-либо. Давайте вспомним пример с сайдбаром. Как бы мы использовали этот модуль в другой части страницы, например в подвале? Нам пришлось бы дублировать правила.

```css
/* Дублирование правил */
#sidebar div, #footer div {
  border: 1px solid #333;
}

#sidebar div h3, #footer div h3 { 
  margin-top: 5px;
}

#sidebar div ul, #footer div ul {
  margin-bottom: 5px; 
} 
```

Корневой элемент модуля — `div`, и мы должны начинать стилизацию с него.

```css
/* Упрощение правил */
.pod {
  border: 1px solid #333;
}

.pod > h3 { 
  margin-top: 5px;
}

.pod > ul {
  margin-bottom: 5px; 
} 
```

Теперь `pod` — это контейнер, который всё ещё зависит от определённой структуры разметки, но зато мы добились гораздо меньшей вложенности, чем была изначально. Компромисс заключается в том, что нам придётся несколько раз повторять класс `.pod` в нашей разметке, тогда как раньше мы имели лишь два элемента с идентификаторами. Конечно, мы хотим избежать возвращения в те дни, когда нам приходилось делать глупые вещи вроде добавления класса к каждому абзацу.

Преимущество использования такой маленькой глубины применения также заключается в том, что мы можем легко конвертировать эти модули в шаблоны для динамического контента. Например, в Yahoo! мы использовали шаблонизатор Mustache для большинства наших нужд. Ниже представлен пример того, как мы можем настроить наш шаблон:

```html
<!-- Пример Mustache-шаблона -->
<div class="pod">
  <h3>{{heading}}</h3>
  <ul>
    {{#items}}
    <li>{{item}}</li>
    {{/items}}
  </ul>
</div> 
```

Мы пытаемся найти баланс между обслуживанием, производительностью и читабельностью. Слишком глубокая вложенность может привести к меньшему количеству классов в вашей разметке, но это увеличивает затраты на обслуживание и ухудшает читабельность. Также вам не нужно добавлять классы ко всему подряд. Добавление классов к `h3` или `ul` в данном примере было бы излишеством, если бы нам не требовалась ещё более гибкая система.

Рассмотрим последний пример ещё глубже. Этот шаблон проектирования является довольно распространённым. Это контейнер с заголовком и содержимым. (Иногда в него также будет входить футер). В конкретно этом примере внутри контейнера располагается `ul`, но это также может быть и `ol` или `div`.

Ещё раз, мы можем дублировать наши правила для каждой вариации.

```css
/* Дублирование правил */
.pod > ul, .pod > ol, .pod > div {
  margin-bottom: 5px; 
} 
```

В качестве альтернативы мы можем просто сделать общий класс для содержимого контейнера:

```css
/* Упрощение с помощью класса */
.pod-body {
  margin-bottom: 5px; 
} 
```

При использовании модульного подхода нам даже не потребуется указывать класс `.pod`. Мы можем визуально определить, что `.pod-body` связан с модулем `pod`, и с точки зрения кода это будет прекрасно работать.

```html
/* Пример Mustache-шаблона */
<div class="pod">
  <h3>{{heading}}</h3>
  <ul class="pod-body">
    {{#items}}
    <li>{{item}}</li>
    {{/items}}
  </ul>
</div> 
```

В результате этого небольшого изменения мы смогли снизить глубину применения до наименьшего значения. Одиночный селектор также означает то, что мы избавляемся от потенциальных проблем со специфичностью. В общем, это беспроигрышный вариант.