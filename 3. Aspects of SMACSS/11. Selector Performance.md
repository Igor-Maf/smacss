# Производительность селекторов
В моей работе мне часто приходится исследовать производительность. Мы используем некоторое количество инструментов для поиска слабых мест нашего приложения. Одним из этих инструментов является [Google Page Speed](http://code.google.com/speed/page-speed). Этот инструмент предоставляет рекомендации по улучшению JavaScript и по увеличению скорости отрисовки страницы. Перед тем, как мы погрузимся в эти рекомендации, нам потребуется понять, как браузеры обрабатывает CSS.

## Как обрабатывается CSS
### Стиль элемента обрабатывается при создании элемента
Мы часто думаем о наших страницах, как о полных и завершённых документах, наполненных контентом. Однако браузеры спроектированы так, что они обрабатывают документ как поток. Они начинают получение документа с сервера и они могут отрисовать его ещё до того, как он окончательно загрузится. Каждый DOM-узел обрабатывается и отрисовывается сразу после того, как он будет загружен.

```html
<!-- Пример HTML-документа -->
<body>
   <div id="content">
      <div class="module intro">
         <p>Lorem Ipsum</p>
      </div>
      <div class="module">
         <p>Lorem Ipsum</p>
         <p>Lorem Ipsum</p>
         <p>Lorem Ipsum <span>Test</span></p>
      </div>
   </div>
</body>
```

Браузер начинает с верха и видит элемент `body`. В этой точке он думает, что этот элемент пустой. Он ещё не обработал ничего другого. Браузер определит вычисленные стили и применит их к элементу. Какой нужен шрифт, цвет, высота строки? После того, как он определит всё это, он отрисует элемент на экране.

Далее браузер видит элемент `div` с идентификатором `content`. Он снова думает, что данный элемент пуст. Он так же не обработал ничего другого. Браузер определяет стили, и `div` отрисовывается. Браузер также определит, требуется ли перерисовать `body` — стал ли этот элемент шире или выше? (Есть и другие вещи, влияющие на отрисовку, но изменение высоты или ширины — это основные причины перерисовки родительских элементов).

Этот процесс продолжается до тех пор, пока браузер не достигнет конца документа.

Если хотите пронаблюдать визуализацию процесса перерасчета DOM-дерева / перерисовки страницы в браузере Firefox, посетите [http://youtu.be/ZTnIxIA5KGw](http://youtu.be/ZTnIxIA5KGw).

### CSS обрабатывается справа налево
Чтобы определить, к каким конкретно элементам применить стили, браузер начинает обработку с правого края селектора и движется влево.

Если у вас есть блок правил вроде `body div#content p { color: #003366; }`, то браузер проверит все элементы на странице на то, являются ли они элементом `p`. Если являются, то он продолжит поиск по родительским элементам — являются ли они элементом `div` с идентификатором `content`. Если он найдёт совпадения, он так же продолжит поиск следующих родителей, пока не дойдёт до `body`.

С помощью обработки справа налево браузер может быстрее определить, какие стили применяются к конкретному элементу, который должен быть отрисован на странице. Чтобы определить, какой селектор более или менее производителен, вам треубется понять, сколько узлов DOM должны быть обработаны перед применением стилей к элементу.

## Какие правила правят?
Так как каждый элемент должен быть отрисован, браузеру нужно понять .какие стили применять к определённым элементам. Давайте взглянем на [рекомендации](http://code.google.com/speed/page-speed/docs/rendering.html#UseEfficientCSSSelectors) Google Page Speed. Есть четыре основных типа правил, которые признаны неэффективными:

* Правила с дочерними селекторами, например `#content h3`
* Правила с селекторами по потомкам первого уровня, например `#content > h3`
* Правила c перегруженными селекторами, например `div#content > h3`
* Правила, применяющие `:hover` не к ссылкам, например `div#content:hover`

Из этих рекомендаций можно сделать вывод о том, что обработка более чем одного элемента для применения стилей является неэффективной. Это значит, что вы можете использовать только простой одиночный селектор по классу, идентификатору, элементу или атрибуту. Если беспрекословно выполнять эти рекомендации, то мы вернёмся назад в дни, когда присваивание класса к каждому абзацу текста было нормой (`<p class="bodytext"></p>`). (И если вы посмотрите на CSS продуктов вроде поиска или почты Google, вы поймёте, что они следуют этим рекомендациям).