# Правила состояния
Правила состояния - это что-то, что расширяет и переопределяет все остальные правила. Например, секция «аккордеона» может быть в свёрнутом и развернутом состояниях. Сообщение может быть об успешно завершенной операции или об ошибке.

Обычно правила состояния применяются к тем же элементам, к которым применяются правила разметки или базовые модульные классы.


```html
/* Состояние, применённое к элементу */
<div id="header" class="is-collapsed">
  <form>
    <div class="msg is-error">
      There is an error!
    </div>
    <label for="searchbox" class="is-hidden">Search</label>
    <input type="search" id="searchbox">
  </form>
</div>
```
    
У заголовка есть только ID. Из этого можно сделать вывод, что все стили (если они есть), примененные к этому элементу, относятся к вёрстке и что `is-collapsed` отвечает за свёрнутое состояние. Можно предположить, что без этого класса состояния элемент по умолчанию развёрнут.

Модуль `msg` достаточно прост, к нему применено состояние «ошибка». Можно предположить, что к этому модулю также возможно применение состояния успешного завершения.

Наконец, у `label` есть состояние `hidden`, позволяющее скрыть от нас элемент, но оставить его видимым для парсеров. В этом случае мы применяем состояние к элементу и не переопределяем стилей вёрстки или модуля.

## А может быть это всего лишь модуль?
Есть достаточно много сходств между подклассом модуля и правилом состояния. Они оба изменяют нынешний вид элемента. Однако, они различаются в двух ключевых моментах:

1. Правила состояния могут применяться к вёрстке или модулям.
2. Правила состояния определяют зависимость от JavaScript.

Второй пункт говорит об основном отличии. Подклассовые стили применяются к элементу в момент рендеринга и больше никогда не меняются. А правила состояния применяются для определения состояния элемента в конкретный момент времени.

Например, нажатие на вкладку активирует её. Поэтому классы `is-active` или `is-tab-active` применимы в этом случае. Нажатие на кнопку закрытия диалогового окна скроет это окно. Поэтому класс `is-hidden` также применим.
 
## Использование !important
Состояния должны быть самостоятельным. Обычно они состоят из одноклассового селектора.

Посколько состояние, скорее всего, будет переопределять стили более сложных наборов правил, использование `!important` разрешено, и даже, осмелюсь сказать, рекомендуется. (Раньше я говорил, что `!important` никогда не используется, но в сложных системах это может быть необходимо.) Скорее всего, вам не придётся применять к элементу два или более состояния, так что проблемы специфичности могут вас не беспокоить.

И всё же будьте осторожны. Отложите использование `!important` до того момента, когда оно действительно станет необходимо (вы поймёте почему, когда увидите следующий пример). И помните — следует избегать использования `!important` с другими типами правил, оно применим только к состояниям.

## Использование правил состояния вместе с модулями
К сожалению, правило состояния не может использовать наследование, чтобы применить стили к другому элементу. Бывает, что состояние каждого модуля уникально, вследствие чего оно требует уникальной стилизации.

В случае, если состояние сделано для специального модуля, в имя класса этого состояния следует включить имя модуля. Кроме того, стили данного состояния стоит расположить вместе со стилями модуля, а не со стилями глобальных состояний.

```css
/* Правила состояния для модулей: */
.tab {
  background-color: purple;
  color: white;
}

.is-tab-active {
  background-color: white;
  color: black;
}
```
    
Если вы загружаете CSS по мере необходимости, а не сразу, то основные состояния должны быть включены в базовые и глобальные стили, загружающиеся при открытии страницы. Стили для отдельного модуля не требуется загружать до тех пор, пока не будет загружен сам модуль.