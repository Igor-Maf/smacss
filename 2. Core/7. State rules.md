# Правила состояния #

Правило состояния - это что-то, что расширяет и переопределяет все остальные правила. Например, секции "аккордеона" могут быть в свернутом и развернутом состояниях. Сообщение может быть об успешно завершенной операции или об ошибке.

Обычно правила состояния применяются к тем же элементам, к которым применяются правила разметки или базовые модульные классы.

**Состояние, примененное к элементу:**

    <div id="header" class="is-collapsed">
        <form>
            <div class="msg is-error">
                There is an error!
            </div>
            <label for="searchbox" class="is-hidden">Search</label>
            <input type="search" id="searchbox">
        </form>
    </div>
    
У заголовка есть только ID. Из этого можно заключить, что все стили, примененные к этому элементу, сделаны только для разметки, и что `is-collapsed` отвечает за свернутое состояние. Можно предположить, что без этого правила элемент по умолчанию развернут.

Модуль `msg` достаточно простой и содержит состояние ошибки. Можно предположить, что в другом случае у элемента может быть состояние успешного завершения.

И наконец, у `label` есть состояние `hidden`, чтобы сделать элемент невидимым для взгляда, но оставить его видимым для парсеров. В этом случае мы применяем состояние к базовому элементу и не переопределяем стилей разметки или модуля.

### А может быть это всего лишь модуль? ###

Есть достаточно сходств между подклассовым модулем и правилом состояния. Они оба изменяют нынешний вид элемента. Однако, они различаются в двух ключевых моментах:

1. Правила состояния могут применяться к правилам разметки или модульным правилам.
2. Правила состояния показывают, что есть JavaScript зависимость.

Второй пункт говорит об основном отличии. Подклассовые стили применяются к элементу в момент рендеринга и больше никогда не меняются. С другой стороны, правила состояния применяются, чтобы показать изменения в состоянии элементов, не перезагружая страницы. 

Например, нажатие на вкладку активирует её. Поэтому классы `is-active` и `ia-tab-active` применимы здесь. Нажатие на кнопку закрытия диалогового окна закроет это окно. Поэтому класс `is-hidden` здесь тоже применим.
 
## Использование !important ##

Состояния стоит делать независимо от остальных стилей и обычно они состоят из одного селектора класса.

Посколько состояние, скорее всего, будет переопределять стили более сложных блоков правил, использование `!important` разрешено, и даже, осмелюсь сказать, рекомендуется. (Раньше я говорил, что `!important` никогда не используется, но в сложных системах он может быть необходимостью.) Обычно вам не будет нужно применять два состояния одновременно к одному элементу, поэтому конфликты между правилами с `!important` должны быть редкостью.

И всё же, будьте осторожны. Оставьте использование `!important` до момента когда он вам совершенно действительно необходим (и вы увидите, почему, в следующем примере). И помните, нужно избегать использования `!important` с другими типами правил, он применим только к состояниям.

## Использование правил состояния вместе с модулями ##

К сожалению, состояние не может всегда полагаться на наследование, чтобы применить стили в нужном месте. Бывает, что стилизация каждого модуля уникальна и каждый из них требует отдельных стилей состояния.

В случае, если состояние сделано специально для модуля, в имя класса состояния стоит включить имя модуля. Помимо этого, стили состояния стоит расположить со стилями модуля, а не с остальными стилями состояния.

**Правила состояния для модулей:**

    .tab {
        background-color: purple;
        color: white;
    }
    
    .is-tab-active {
        background-color: white;
        color: black;
    }
    
Если вы хотите ускорить загрузку CSS, правила состояния должны быть частью основы и глобальных стилей и включены при загрузке страницы. Стили состояния определенного модуля не нужно подгружать до того, как стили самого модуля загружены.