# Классифицируем CSS-правила
Каждый проект требует определённой организации. Написание каждой строчки новых стилей в конце единственного файла усложняет поиск чего-либо в этом файле и делает проект ещё более запутанным для кого-то другого. Конечно, вы уже наверняка организовали ваш код определённым образом. Надеюсь, что чтение этой книги позволит вам выделить то, что хорошо работает в вашем текущем процессе и, если мне повезёт, вы найдёте новые способы улучшения процесса вашей работы.

Как вы решаете, использовать ли селектор по идентификатору, по классу, или любой другой селектор, имеющийся в вашем распоряжении? Как вы решаете, какие элементы должны быть одарованы стилями? Как вы упрощаете для понимания то, как организован ваш сайт и ваши стили?

В основе SMACSS лежит классификация. С помощью классификации CSS-правил мы начинаем видеть определённые паттерны и определять лучшие практики по использованию этих паттернов.

В SMACSS есть пять категорий:

1. База
2. Макет
3. Модуль
4. Состояние
5. Тема

Мы зачастую смешиваем стили, относящиеся к этим категориям. Если мы осведомлены о том, что мы пытаемся стилизовать, мы можем избежать сложностей, вызванных смешиванием стилей.

Каждая категория имеет определённые рекомендации, относящиеся к ней. Это несколько лаконичное разделение на категории позволяет нам задавать самим себе вопросы в процессе разработки. Как мы собираемся закодить что-то и почему мы собираемся закодить это именно таким способом?

Главная цель классификации чего-либо заключается в систематизации паттернов — вещей, которые повторяются в рамках нашего дизайна. Использование паттернов приводит к меньшему количеству кода, лёгкой поддержке и большей логичности. Всё это выгодно. Исключения из этого правила бывают полезны, но они должны быть оправданы.

**Базовые правила** — это правила по умолчанию. Чаще всего они представлены селектором по одному элементу, но они также могут включать в себя селекторы по атрибутам, псевдоклассам, элементам-потомкам и так далее. По сути, базовые правила определяют стили элемента, которые не меняются в зависимости от расположения этого самого элемента.


```css
/* Пример базовых стилей */
html, body, form { margin: 0; padding: 0; }
input[type=text] { border: 1px solid #999; }
a { color: #039; }
a:hover { color: #03C; }
```

**Правила макета** разделяют страницу на секции. Макеты объединяют определённое количество модулей.

**Правила состояния** описывают то, как наши модули или макеты должны выглядеть в различных состояниях. Скрыты они или отображены? Активны или неактивны? Эти правила также описывают то, как модули или макеты выглядят на разных экранах — больших и маленьких. Кроме того, они описывают то, как модули могут выглядеть в разных местах, таких как главная или внутренняя страница.

**Правила темы** похожи на правила состояния тем, что они описывают то, как модули или макеты могут выглядеть. Большинство сайтов не требует темизации, но хорошо иметь её ввиду.

## Соглашение по именованию
В связи с разделением правил на пять категорий наличие определённого соглашения по именованию поможет сразу понять, к какой из категорий относится определённый стиль и какова его роль в пределах всей страницы. При работе над большими проектами предпочтительно разделить стили на множетсво файлов. Поэтому наличие правил именования также сделает понятнее то, к какому файлу относится определённый стиль.

Мне нравится использовать префиксы для разделения между правилами Макета, Состояния и Модуля. Для Макета я использую `l-`, но `layout-` будет работать так же хорошо. Использование префиксов вроде `grid-` также вносит достаточно ясности при отделении стилей макета от других стилей. Для правил состояния я использю `is-`, например `is-hidden` или `is-collapsed`. Это помогает создавать весьма читаемые и понятные стили.

Модули являются основной частью любого проекта. В связи с этим добавление префикса вроде `.module-` к каждому из модулей было бы излишне многословным. Поэтому модули не используют префиксов, а имеют лишь своё собственное имя.

```css
/* Примеры классов */

/* Example Module */
.example { }

/* Callout Module */
.callout { }

/* Callout Module with State */
.callout.is-collapsed { }

/* Form field module */
.field { }

/* Inline layout  */
.l-inline { }
```

Связанные с модулем элементы должны использовать его имя в качестве префикса. На этом сайте примеры кода используют `.exm`, а подписи к примерам — `.exm-caption`. Я могу посмотреть на класс подписи и мгновенно понять, что она связана с примером кода, а также где я могу найти стили для неё. 

Модули, которые являются вариациями другого модуля, тоже должны использовать имя базового модуля в качестве префикса. Такое именование подробнее описано в главе «Правила модуля».

Эти соглашения по именованию будут использоваться на протяжении всей этой книги. Помните, что вы не обязаны жёстко следовать этим правилам, как и многим другим вещам, которые я изложил в этой книге. Глваное — имейте определённые соглашения, задокументируйте их и придерживайтесь им.