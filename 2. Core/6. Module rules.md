# Правила модулей
Как было упомянуто в предыдущей главе, модуль является более обособленным компонентом страницы. Им может быть меню, слайдер, диалоговое окно, виджет и тому подобное. Модули — это основные составляющие страницы. Модули могут находиться как внутри макета, так и внутри других модулей. Каждый модуль должен создаваться как отдельный, не зависящий от других модулей компонент. Благодаря такому подходу страница будет более гибкой — модули можно будет легко перемещать в разные части макета, при этом не ломая сам макет.

При описании правил модуля избегайте использования селекторов по идентификаторам и именам тегов. Используйте только селекторы по классу. Скорее всего, модуль будет содержать в себе какое-то количество элементов, и было бы неплохо использовать селектор по потомкам для стилизации этих элементов. 

```css
/* Пример модуля */
.module > h2 {
  padding: 5px;
}

.module span {
  padding: 5px;
}
```

## Избегайте селекторов по элементам
Используйте селекторы по потомкам вместе с селекторами по элементам, если вторые являются легко предсказуемыми. Использовать `.module span` хорошо, если использование `span` будет предсказуемо и если модуль всегда будет размечен одинаково.

```html
<!-- Стилизация с предсказуемым элементом-->
<div class="fld">
  <span>Имя папки</span>
</div>
```

```css
/* Модуль Folder */
.fld > span {
  padding-left: 20px;
  background: url(icon.png);
}
```

Проблемой является то, что чем больше функционала вы будете добавлять в ваш модуль, тем больше ограничений появится из-за использования селектора по элементу.

```html
<!-- Разметка вложенных элементов -->
<div class="fld">
    <span>Имя папки</span> 
    <span>(32 элемента)</span>
</div>
```

Теперь мы оказались в неприятном положении. Мы не хотим, чтобы иконка появлялась на обоих элементах внутри нашего модуля. И это приводит нас к следующей части моего повествования: 

*Используйте селекторы, которые несут в себе смысл*. Сами по себе `Span` или `div` ничего не значат. Класс, заданный элементу, может рассказать нам многое.

```html
<!-- Разметка вложенных элементов -->
<div class="fld">
    <span class="fld-name">Имя блока</span> 
    <span class="fld-items">(еще 32 элемента)</span>
</div>
```

Благодаря добавлению классов мы улучшили понимание смысла этих элементов и избавились от какой-либо неясности при их стилизации.

**Если вы все же хотите использовать селектор по элементу, он должен использоваться в пределах одного уровня с классовым селектором. Дргими словами, использование потомковых селекторов крайне ситуативно. С другой стороны, вы должны быть полностью уверены, что один элемент не будет спутан с другим. Такие элементы, как span или div, скорее всего только создадут вам дополнительные проблемы. Однако элементы, вроде заголовков, скорее всего появятся лишь один раз внутри одного блока, и использование селекторов по элементу на них не приведет ни к каким конфликтам.** — требует вычитки

## Новые контексты
Использование модульного подхода также позволяет нам лучше понять, где, скорее всего, произойдет изменение контекста. Потребность в новом позиционировании контекста, к примеру, может произойти на любом уровне макета или в корне модуля.

## Подклассовое модулирование
Когда мы имеем одинаковые модули в разных секциях, первым порывом может являться использование элемента родителя для разметки этого модуля по другому.

```css
/* Подклассы */
.pod { 
    width: 100%; 
}
.pod input[type=text] { 
    width: 50%; 
}
#sidebar .pod input[type=text] { 
    width: 100%; 
}
```

Проблемой данного подхода является то, что мы легко можем столкнуться со спецефическими проблемами, из-за которых нам придется использовать еще больше селекторов или даже скатиться до использования !important.

Говоря о приведенном выше примере, у нас есть поля ввода с различной шириной. В основной части сайта поле ввода имеет подпись рядом с ним, и должно занимать лишь половину ширины всего родительского элемента. Однако, в боковой панели поле ввода было бы слишком маленьким, так что мы увеличим его ширину до 100%, а подпись сделаем сверху. Пока что все идет хорошо. Теперь нам нужно добавить новый элемент на нашу страницу. Большинство его разметки совпадает с блоком .pod, так что мы используем этот класс еще раз. Однако, новый элемент особенный, и имеет ограниченную ширину, в какой части страницы бы он не находился. 

```css
/* Боремся со специфичностью */
.pod { 
    width: 100%; 
} 
.pod input[type=text] { 
    width: 50%; 
}
#sidebar .pod input[type=text] { 
    width: 100%; 
}

.pod-callout { 
    width: 200px; 
}
#sidebar .pod-callout input[type=text],
.pod-callout input[type=text] { 
    width: 180px; 
}
```

Нам приходится использовать два селектора, чтобы наши изменения были в силе и внутри боковой панели.

Что нам следует сделать вместо этого, так это вспомнить, что наш ограниченный блок является подклассом .pod и соответствующе его разметить.

```css
.pod { 
    width: 100%; 
} 
.pod input[type=text] { 
    width: 50%; 
}
.pod-constrained input[type=text] { 
    width: 100%; 
}

.pod-callout { 
    width: 200px; 
}
.pod-callout input[type=text] { 
    width: 180px; 
}
```

С применением подклассов, как основной, так и вторичный класс будут применены к HTML элементу.

```html
<!-- Подклассы в HTML -->
<div class="pod pod-constrained">...</div>
<div class="pod pod-callout">...</div> 
```

Старайтесь избегать условной разметки элемента. Если вы изменяете внешний вид модуля где-то в другом месте на странице, используйте подклассы вместо сложных условий и вложений.

Если вас не беспокоит совместимость с IE6, вы можете использовать селекторы так,

```css
/* Подклассы */
.pod.pod-callout { }
```

выбирая именно интересующий нас элемент.

```html
<!-- Наш HTML -->
<div class="pod pod-callout"> ... </div>
```

Однако будьте осторожны, если вы используйте несколько файлов, которые загружаются по очереди. К примеру, на почте Yahoo!, у нас имеется код, загружающийся из разных мест. Были как основные стили для кнопок, так и специальный набор кнопок для экрана написания нового письма. Однако, при нажатии на "Добавить контакт", загружался дополнительный компонент от совсем другого нашего продукта: Адресной книги. (Да, адрессная книга - другой продукт внутри Yahoo!.) Та, в свою очередь, загружала свои собственные стили кнопок, тем самым изменяя стили подклассовых кнопок на основной странице.

Если вы загружаете файлы из различных мест, будьте готовы к проблемам спецификации.

Несмотря на то, что использование ID может быть использованно для разметки именно интересующего нас модуля, подклассы позволяют модулю легко перемещаться между секциями всего сайта и избавляют вас он лишних проблем со спецификацией.